# Process Thread 정리

## 목차

1. [운영체제는 왜 등장했을까?](#운영체제는-왜-등장했을까)
2. [System Call](#system-call)
3. [Process](#process)
4. [Process 생성과정](#process-생성-과정)
5. [Process LifeCycle](#process-lifecycle)
6. [PCB](#pcb)
7. [Context Switch](#context-switch)
8. [Thread](#thread)
9. [Process, Thread Memory](#process-thread-memory)
10. [multi tasking, multi processing](#multi-tasking-multi-processing)

### 운영체제는 왜 등장했을까?

‘이렇게 비싼 컴퓨터를 어떻게 효율적으로 활용할까?’, ‘컴퓨터가 입출력하는 동안 다른 프로그램을 실행하면 좋지 않을까?’ 라는 생각에 컴퓨터를 운영해주는 프로그램인 운영체제를 떠올렸다.

즉, 운영체제는 컴퓨터 운영의 효율성, 편리성 향상을 위해 등장했다.

### System Call

운영체제는 프로그램이며 입/출력 장치 등 하드웨어를 관리한다.

우리가 하드웨어에 직접 명령하면 운영체제와 충돌이 날 수 있기 때문에 운영체제에 명령해야한다.

아무나 운영체제에 명령할 수 없기에 적절한 권한을 얻어야하는데 이를 `System Call`이라고 한다.

프로세스의 권한이 user mode → kernel mode로 넘어가게 된다.

user mode: 사용자 프로그램들이 수행 (권한↓)

kernel mode: 운영체제의 커널 수행 (권한↑)

---

### Process

운영체제는 프로그램의 실행을 돕기 위해 등장했고 정말 중요한 건 프로그램의 실행이다.

프로세스는 **실행중**인 프로그램이다.

→ **실행중**이란, 운영체제에 의해 메모리, CPU 등 시스템 자원을 할당받아 작업을 수행하는 상태이다.

또한, 프로세스는 포그라운드 프로세스와 백그라운드 프로세스로 나뉜다.

> **프로그램이란?**
> 어떤 문제를 해결하기 위하여 그 처리 방법과 순서를 기술하여 컴퓨터에 주어지는 일련의 명령문 집합체.

그럼, 우리의 컴퓨터에서 프로세스가 어떤 형태로 존재하는지 확인해보자.

아래는 시스템의 자원 할당에 대한 사진이다.

<img width="1410" alt="image" src="https://github.com/user-attachments/assets/2dd75451-cd72-4075-bede-5f1cf471a5c3" />

프로세스가 598개 존재함을 확인할 수 있는데, 프로세스들은 CPU 자원을 사이좋게 나눠 사용하고 있다.

<img width="271" alt="image 1" src="https://github.com/user-attachments/assets/7e24c1ca-b3fd-403b-8edd-e0f8dc3c868c" />

그렇다면, 이렇게 수 많은 프로세스를 어떻게 적은 양의 CPU 코어로 관리할까?(내 컴퓨터의 코어는 8 Core이다.)

프로세스의 상태를 나누어 많은 프로세스들을 관리하게 되는데, 프로세스의 생성과정과 라이프사이클에 대해 알아보자

### Process 생성 과정

1. 프로그램 코드를 메모리로 적재한다. - Load
   - 게으른 방식으로 필요할 때마다 가져옴
2. 실행시간 스택 할당
3. 힙 생성
   - 실행 도중 동적으로 요구되는 공간 할당을 위한 영역
4. 입출력 초기화 작업
   - stdin, stdout, stderr 장치와 연결 설정
   - I/O 또는 시그널 관련 자료구조 초기화
5. 프로그램 시작점으로 분기하여 실행 시작
   - 주로 main()

### Process LifeCycle

![image 2](https://github.com/user-attachments/assets/6563fa01-c916-4666-a7b7-1d7aef6a00d2)

New는 시작, Exit는 종료이다. 나머지 세 가지 상태를 알아보자.

Ready: 프로세스가 Running에 대한 준비 상태. 메모리에 올라간 상태다. CPU 자원 할당 X

Running: 프로세스가 메모리에 올라가 CPU 자원을 할당 받은 상태다.

Blocked: 대기 상태인데, 이 때는 프로세스가 메모리에서 내려와 Disk로 이동하기도 한다.

### PCB

그럼 프로세스의 상태에 대한 정보, 처리는 어떻게 할까?

Process Control Block(PCB)을 활용

프로세스가 생성될 때 운영체제는 PCB를 생성

![image 3](https://github.com/user-attachments/assets/4ad3d326-ea67-45a9-9754-8d6759dc6775)

### Context Switch

그렇다면 이제 실제 프로세스 간의 CPU 바톤 터치를 할때는 어떻게 할까?

- PC, 레지스터 등 program context 저장
- 프로세스의 제어블록 갱신
- 프로세스 제어블록 → 적절한 큐로 옮김
- 다음에 수행할 프로세스 선택
- 선택한 프로세스의 제어블록 갱신(to running)
- 메모리 관리와 관련된 자료구조 갱신
- 선택한 프로세스가 사용하던 context를 복원

이러한 절차를 `Context Switch`라고 한다.

프로세스, 스레드 모두 컨텍스트 스위칭이 가능하다.

프로세스는 PCB, 스레드는 TCB를 사용해 Context가 관리된다.

그렇다면 이런 프로세스 교환시점은 언제 발생할까?

`운영체제가 프로세스로부터 제어를 받을 때`이다.

- 운영체제가 프로세스로부터 제어를 받을 때
  - 인터럽트: 現 명령어 외부 (비동기 이벤트 등)
    - 클럭 인터럽트: 시간 다 됐을 때
    - 입출력 인터럽트
    - 메모리 폴트
  - 트랩: 現 명령어 수행 관련 (오류, 예외 등)
  - Supervisor 호출: 명시적 요청 (운영체제 기능 호출 등)

여기서 알아야 할 것은 현재 Running상태인 프로세스가 멈추고 운영체제가 업무를 보게 된다는 것이다.

우리의 목표가 무엇인지 다시 상기해보자. ⇒ 우리의 목표: 프로그램을 실행하는 것

즉, Context Switch를 하는 순간 우리는 손해를 보게 된다.

그래서 이것을 최소화하는 방향으로 스케쥴링 알고리즘과 멀티 스레딩 등 여러 기법들이 필요해진다.

---

### Thread

프로세스가 운영체제로부터 자원을 할당받고 스케쥴링된다면,
스레드는 프로세스에 의해 관리되고 스케쥴링된다. (물론 이것도 운영체제 정책에 따라 달라질 수 있음)

**스레드는 왜 필요해졌을까?**

위에서 확인했듯이 `Context Switch`는 비용이 크다.

이러한 부분을 개선하기 위해 스레드가 등장한다.

- 스레드 생성 시간이 프로세스 생성 시간보다 짧다.
- 스레드 종료 시간이 프로세스 종료 시간보다 짧다.
- 스레드 교환 오버헤드가 프로세스 교환 오버헤드보다 적다.
- 스레드 간 통신 오버헤드가 프로세스 간 통신 오버헤드보다 적다.

그렇다면 왜 스레드가 프로세스보다 더 빠를까? 메모리 구조를 통해 확인해보자.

### Process, Thread Memory

![image 4](https://github.com/user-attachments/assets/b5491b62-a15c-47b8-90d1-df2a4a8c91bf)

위 사진에서 알 수 있듯이 프로세스는 각각의 자원이 독립적이다.

반면, 스레드는 스택영역을 제외한 부분을 공유한다.

스레드는 메모리를 공유하고 프로세스는 메모리를 공유하지 않는데, 프로세스 끼리 정보를 주고 받을 수 있을까?

IPC, LPC, Shared Memory 등을 활용해서 정보를 주고 받을 수 있다.

이러한 이유로 메모리를 공유하는 스레드에 비해 프로세스의 속도는 느리다.

<br>

**왜 Stack 영역만 독립되어있나??**

Stack은 다들 알다싶이 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 냉서 선언하는 변수 등을 저장하는 메모리 공간이다.

이러한 Stack을 독립되게 가졌다는 것은 독립적인 함수 호출이 가능하다 라는 의미이다. 그리고 독립적인 함수 호출이 가능하다는 것은 곧, 독립적인 실행 흐름이 가능하다는 것이다.

즉, Stack 영역을 독립적으로 가짐으로써 스레드는 독립적인 실행 흐름을 가질 수 있게 되는 것이다.

![image 5](https://github.com/user-attachments/assets/ecec243d-c634-4988-b07d-fd1da270db51)

위 사진은 프로세스의 메모리구조다.

스택과 힙 영역은 동적할당되고 데이터와 코드 영역은 정적할당된다.

코드(텍스트) 영역: 코드가 기계어 형태로 저장

데이터 영역: 전역 변수 저장

스택 영역: 지역 변수, 매개 변수 등 저장 → 반복적으로 호출될 경우 stack overflow 발생

힙 영역: 주소값을 통해 힙 영역의 데이터에 접근하고 크기는 런타임에 결정. ARC에 의해 관리

### multi tasking, multi processing

multi tasking: 단일 Core에서 번갈아가며 여러 작업을 처리하는 것

![image 6](https://github.com/user-attachments/assets/d474eb2b-c627-4fb7-8f09-587a781e242f)

multi processing: 여러개의 Core가 여러 작업을 병렬로 처리하는 것

![image 7](https://github.com/user-attachments/assets/36644282-c4c6-4794-932e-285e5a434b64)

multi tasking + multi processing

![image 8](https://github.com/user-attachments/assets/d9a75265-4527-42d6-83a3-b0afd5f18fbf)

### QNA

1. 프로세스와 스레드의 차이점은 무엇이며, 각각의 메모리 구조는 어떻게 다른가요?

2. 컨텍스트 스위칭(Context Switching)이란 무엇이며, 어떤 상황에서 발생하나요?

3. 스택(Stack)과 힙(Heap)의 차이점은 무엇이며, 각각의 메모리 할당 방식은 어떻게 다른가요?

4. 프로그램과 프로세스의 차이에 대해 자원(CPU, Memory, Disk)의 관점에서 이야기해보세요

5. 스레드가 무엇이고 왜 생겼는지 말해보세요.

6. 멀티프로세스와 멀티스레드의 장, 단점에 대해 설명해주세요.

7. 프로세스가 무엇인가? - PCB는 왜 필요한가요.

8. 스레드와 프로세스의 장점/단점 비교

9. 프로세스와 스레드의 차이를 메모리 관점에서 설명해주세요

10. 멀티 태스킹과 멀티 프로세싱의 차이점을 설명해주세요

11. iOS에서 어떻게 멀티 스레드를 구현할 수 있는지 설명해주세요

12. Thread 사용하면서 불편했던 점이 있었나요?

13. Thread 클래스가 아닌 GCD를 사용하는 이유는 무엇인가요?

14. 스레드가 메모리를 공유함으로써 일어날 수 있는 문제점?
